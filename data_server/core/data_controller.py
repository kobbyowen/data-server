import typing as t
from enum import Enum
from functools import reduce
from datetime import datetime
from uuid import uuid4

from data_server.errors import ItemNotFoundError, DuplicateIDFound
import data_server.typing as dt


class SortOrder(Enum):
    ASC = "asc"
    DESC = "desc"


class DataController:
    def __init__(self, data: t.Dict[t.Text, t.Any], *, id_name: t.Text = "id",
                 sort_key_param_name: t.Text = "sort_by", order_param_name: t.Text = "order",
                 page_param_name: t.Text = "page", size_param_name: t.Text = "size",
                 default_page_size: int = 10, autogenerate_id: bool = False, use_timestamps: bool = False,
                 created_at_key_name: t.Text = "created_at", updated_at_key_name: t.Text = "updated_at"):
        """Initializes a data controller class. DataController is an abstraction that allows querying and modify data
        which is loaded a dictionary.

        Args:
            data (Dict[Text, Any]): The data that will be used. Not, the data is not copied, it is the responsibility
            of the developer to use deepcopy to copy the data before pasing it , if modifications are not allowed
            to copy the data if modifications are not allowed.
            id_name (Text, optional): The key that identifies IDs. Defaults to "id".
            sort_key_param_name (Text, optional): The key that can be used to control sorting. Defaults to "sort_by".
            order_param_name (Text, optional): The key that can be used to control the order of sorting,
            whether ascending or descending. Defaults to "order".
            page_param_name (Text, optional): The key that can be used to control the pagination of items.
            Defaults to "page".
            size_param_name (Text, optional): The key that can be used to cotrol the size for pagination.
            Defaults to "size".
            default_page_size (int, optional): The default size of a page. Defaults to 10.
            autogenerate_id (bool, optional): Whether ids be autogenerated when adding a new item. Defaults to False.
            use_timestamps (bool, optional): Whether timestamps should be used or not. If set timestamps will be added
            when new items are added, and updated when items are modified. Defaults to False.
            created_at_key_name (Text, optional): The key name for timestamps that represents when the item was added.
            Defaults to "created_at".
            updated_at_key_name (Text, optional): The key name for timestamps that represents when the item was added.
            Defaults to "updated_at".
        """
        self.data = data
        self.id_name = id_name
        self.sort_key_param_name = sort_key_param_name
        self.order_param_name = order_param_name
        self.page_param_name = page_param_name
        self.size_param_name = size_param_name
        self.default_page_size = default_page_size
        self.auto_generate_id = autogenerate_id
        self.use_timestamps = use_timestamps
        self.created_at_timestamp_name = created_at_key_name
        self.updated_at_key_name = updated_at_key_name
        self.id_type = self._get_id_type(data)
        assert isinstance(self.data, dict), f"data must be of type dict not {type(self.data)}"

    def get_items(self, path: dt.ItemPath, **filters: t.Any) -> dt.JSONItems:
        """Retrieve a list of items from data

        Args:
            path (ItemPath): The path used to navigate to the item.
            filters: The key and values that will be used to filter the data and sort the data

        Returns:
            JSONItems: The list of items after applying the filters.  ItemNotFoundError is raised
            if the path does not exist.
        """
        items = self._get_item_by_path_only(path)
        assert isinstance(
            items, list), f"Expected value for {path!r} to be a list, got {items} instead"
        return self._get_items(items, **filters)

    def get_item(self, path: dt.ItemPath, id: dt.IdType) -> dt.JSONItem:
        """Retrieve an item from the data.

        Args:
            path (ItemPath): The path used to navigate to the item.
            id (IdType): The id used to identify the item.

        Returns:
            JSONItem: The item. ItemNotFoundError is raised if the path or id does not exist.
        """
        return self._get_item_by_path_and_id(path, id)

    def delete_item(self, path: dt.ItemPath, id: dt.IdType) -> None:
        """Delete an item from data

        Args:
            path (ItemPath): The path used to navigate to the item.
            id (IdType): The id used to identify the item.
        """
        parent, index = self._get_item_parent_and_index(path, id)
        del parent[index]

    def patch_item(self, path: dt.ItemPath, id: dt.IdType, new_data: dt.JSONItem) -> dt.JSONItem:
        """Patch an item. Replace and item's old values with new values in new_data parameter.
        Updates timestamps if use_timestamp is set to True

        Args:
            path (ItemPath): The path used to navigate to the item. ItemNotFoundError is raised
            if path is not found.
            id (IdType): The id used to identify the item.
            new_data (JSONItem): The new values for the item

        Raises:
            ValueError: trying to patch the id of an item

        Returns:
            JSONItem: The new item after applying the patch
        """
        if self.id_name in new_data:
            raise ValueError("id cannot be patched")
        parent, index = self._get_item_parent_and_index(path, id)
        parent[index].update(new_data)
        return self._update_timestamps(parent[index])

    def replace_item(self, path: dt.ItemPath, id: dt.IdType, new_data: dt.JSONItem) -> dt.JSONItem:
        """Replace and item's old values with new values in new_data parameter, unnlike patch,
        this replaces the item completely. Updates timestamps if use_timestamp is set to True

        Args:
            path (ItemPath): The path used to navigate to the item. ItemNotFoundError is raised
            if path is not found.
            id (IdType): The id used to identify the item.
            new_data (JSONItem): The new values for the item.

        Raises:
            ValueError: trying to replace the id of an item

        Returns:
            JSONItem: The new item after replacing it.
        """
        if self.id_name in new_data:
            raise ValueError("id cannot be replaced")
        parent, index = self._get_item_parent_and_index(path, id)
        parent[index] = {**new_data, self.id_name: id}
        return self._update_timestamps(parent[index])

    def add_item(self, path: dt.ItemPath, new_data: dt.JSONItem) -> dt.JSONItem:
        """Add an item to data. If auto_generate_id is set to True, ids will be autogenerated.
        Timestamps will be added if use_timestamp is true

        Args:
            path (ItemPath): The path used to navigate to the item. ItemNotFoundError is
            raised if path is not found.
            new_data (JSONItem): The new_data to be added.

        Raises:
            DuplicateIDFound: auto_generate_id is false and incoming id in new_data already exists in items.

        Returns:
            JSONItem: The new item after adding it.
        """
        items = self._get_item_by_path_only(path)
        assert isinstance(
            items, list), f"Expected value for {path!r} to be a list, got {items} instead"
        data = new_data.copy()
        if not self.auto_generate_id and self.id_name in data:
            if [item for item in items if item[self.id_name] == data[self.id_name]]:
                raise DuplicateIDFound(f"an item exists with same id {data[self.id_name]}")
        if self.auto_generate_id and self.id_name not in data:
            data[self.id_name] = self._autogenerate_id(len(items))
        data = self._add_timestamps(data)
        items.append(data)
        return data

    def _get_id_type(self, data: dt.JSONItem) -> t.Optional[type]:
        for key, value in data.items():
            if key == self.id_name:
                return type(value)
            if isinstance(value, list):
                for item in value:
                    return self._get_id_type(item)
            if isinstance(value, dict):
                return self._get_id_type(value)
        return None

    @staticmethod
    def _filter_items(data: dt.JSONItems, **filters: t.Any) -> dt.JSONItems:
        new_data = []
        for item in data:
            for key, value in filters.items():
                if key in item and item[key] != value:
                    break
            else:
                new_data.append(item)
        return new_data

    def _get_item_parent_and_index(self, path: dt.ItemPath, id: dt.IdType) -> t.Tuple[dt.JSONItems, int]:
        items = self._get_item_by_path_only(path)
        assert isinstance(
            items, list), f"Expected value for {path!r} to be a list, got {items} instead"
        try:
            item_index = next(i for i, v in enumerate(items)
                              if v[self.id_name] == id)
        except StopIteration:
            raise ItemNotFoundError("item with id {id} could not be resolved from path {path!r}")
        return items, item_index

    def _get_item_by_path_only(
            self, path: dt.ItemPath) -> dt.JSONResult:
        try:
            value = reduce(lambda prev, cur: t.cast(dt.JSONItem, prev[cur]), path, self.data)
            return value
        except KeyError:
            raise ItemNotFoundError(f"{path} could not be resloved in data")

    def _get_item_by_path_and_id(self, path: dt.ItemPath, id: dt.IdType) -> dt.JSONItem:
        items = self._get_item_by_path_only(path)
        assert isinstance(
            items, list), f"Expected value for {path!r} to be a list, got {items} instead"
        items = list(filter(lambda x: x[self.id_name] == id, items))
        try:
            return items[0]
        except IndexError:
            raise ItemNotFoundError(f"No item with id {id} exists")

    def _update_timestamps(self, item: dt.JSONItem) -> dt.JSONItem:
        if not self.use_timestamps:
            return item
        item[self.updated_at_key_name] = datetime.now().isoformat()
        return item

    def _add_timestamps(self, item: dt.JSONItem, update_updated_at: bool = False) -> dt.JSONItem:
        if not self.use_timestamps:
            return item
        item[self.created_at_timestamp_name] = datetime.now().isoformat()
        item[self.updated_at_key_name] = None if update_updated_at else datetime.now().isoformat()
        return item

    def _get_items(self, data: dt.JSONItems, **filters: t.Any) -> dt.JSONItems:
        sort_key = filters.pop(self.sort_key_param_name, self.id_name)
        self.order = filters.pop(
            self.order_param_name, SortOrder.ASC.value)
        self.order = SortOrder.ASC if self.order.lower(
        ) == SortOrder.ASC.value else SortOrder.DESC
        self.page = filters.pop(self.page_param_name, 0)
        self.size = filters.pop(self.size_param_name, self.default_page_size)
        new_data = self._filter_items(data, **filters)
        new_data.sort(
            key=lambda item: item.get(sort_key, list(self.data.keys())[0]), reverse=self.order == SortOrder.DESC)
        start_index = self.page * self.size
        end_index = start_index + self.size
        return new_data[start_index:end_index]

    def _autogenerate_id(self, data_length: int) -> t.Union[t.Text, int]:
        if self.id_type is int:
            return data_length + 1
        return str(uuid4())
